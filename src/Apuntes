
Dudas:

	- Hace falta definir clases para todos los no terminales? No necesariamente, pero si
	
	- Hace falta asignar RESULT en todas las producciones? No necesariamente, pero si
	
	- Paso de parametros por referencia o valor?
	
	- Se pueden re-definir variables en nuevos bloques?
	
	- Se pueden re-definir variables con el mismo nombre que un parametro?
	
	- Cual es la penalizacion por implementacion incorrecta? (por ejemplo, permitir re-definir un parametro)
	
	


Estructura lenguaje:

	Tipos:
		
		- No se puede definir un tipo en un ambiente inferior con el mismo nombre que otro superior

		- El tamanio del tipo vector tiene que ser una constante o literal, no se aceptan variables
		
		- El tamanio del tipo vector debe ser mayor que 0
		
		- Solo se pueden hacer vectores de enteros, nada mas
		
		- Las funciones solo pueden devolver el tipo entero o vacio
		
		- Los parametros de una funcion solo pueden ser entero o tipo vector de enteros
		
		- Las funciones que retornan tipo vacio no se pueden poner en condiciones o en asignaciones
		

		
Codigo intermedio
	
	- COPY X:Temporal/Variable Y:Temporal/Varible/Value -> Almacenar en X el valor contenido en Y
	
	- POINT X:Temporal/Variable Y:Temporal/Varible -> Almacenar en X la direccion de Y
	
	- FIND X:Temporal/Variable Y:Temporal/Varible -> Almacenar en X el valor almacenado en la direccion a la que apunta el valor conteindo en Y
	
	- STORE X:Temporal/Variable Y:Temporal/Varible/Value -> Almacenar en la direccion a la que apunta el valor contenido en X el valor contenido en Y
	
	- RETURN X:Temporal/Variable/Value -> Retorna de la funcion con el valor almacenado en X
	
	- ADD X:Temporal/Variable Y:Temporal/Variable/Value Z:Temporal/Variable/Value -> Almacenar en X el resultado de sumar los valores contenidos en Y y Z
	
	- MUL X:Temporal/Variable Y:Temporal/Variable/Value Z:Temporal/Variable/Value -> Almacenar en X el resultado de multiplicar los valores contenidos en Y y Z
	
	- GR X:Temporal/Variable Y:Temporal/Variable/Value Z:Temporal/Variable/Value -> Almacenar en X un 1 si el valor de Y es mayor que Z, si no almacena un 0
	
	- LS X:Temporal/Variable Y:Temporal/Variable/Value Z:Temporal/Variable/Value -> Almacenar en X un 1 si el valor de Y es menor que Z, si no almacena un 0
	
	- EQ X:Temporal/Variable Y:Temporal/Variable/Value Z:Temporal/Variable/Value -> Almacenar en X un 1 si el valor de Y es igual que Z, si no almacena un 0
	
	- BR L:Label -> Salta a la etiqueta L
	
	- BRT X:Temporal/Variable/Value L:Label -> Si X > 0, salta a L
	
	- BRF X:Temporal/Variable/Value L:Label -> Si X < 1, salta a L
	
	- INL L:Label -> Inserta la etiqueta L
	
	- PRINT_STR L:Label -> Muestra por pantalla la cadena L
	
	- PRINT_INT X:Temporal/Variable/Value -> Muestra por pantalla el valor de X
	
	- PRINT_LINE -> Crea un salto de linea en pantalla
	
	- CADENA L:Label S:String -> Inserta una etiqueta L con los datos S
	
	- SET_STACK_POINTER X:Value -> Pone el StackPointer al valor de X
	